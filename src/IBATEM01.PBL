.******************************************************************************
.* System  : IBA SYSTEM                                                       *
.* Program : IBATEM01                                                         *
.* Desc    : Stationery Template Maintenance                                  *
.******************************************************************************
.* Date    : 31/01/90                                                         *
.* Author  : DIG                                                              *
.******************************************************************************
.* Mods     :                                                                 *
.*       V10.11.01   12/10/2017  Ania P                  CAR 261630           *
.*                   Removed use of PORT and IBCNTMDM                         *
.*       V10.09.01   04/01/2017  Steve Armstrong         TSK 0319852          *
.*                   Added new variables (IBTHSTYP, IBTHACTV and IBTHCOMM to  *
.*                   IBTHUTIM) to CLR0000                                     *
.******************************************************************************
.*       V10.03.01   25/10/2012  Patrick Adair           CAR 273181           *
.*                   Recompiled for IBADSTYP                                  *
.******************************************************************************
.*        V9.12.01   30/09/2009  Peter Vela   CAR 205008                      *
.*                   Recompiled for IBADSTYP                                  *
.*        V9.10.01   29/07/2008  Peter Vela   CAR 151951                      *
.*                   Recompiled for IBADSTYP                                  *
.*        V9.08.01   23/03/2007  Peter Vela   CAR 128233                      *
.*                   Recompiled for IBADSTYP                                  *
.*        V9.05.01   22/03/2006  Peter Vela   CAR 61299                       *
.*                   Increased field no size from DIM3 to DIM5                *
.*        V9.04.01   17/03/2005  Lina Vo      CAR 56405                       *
.*                   Added IBASTP18 - Theatre Form Stationary Type            *
.******************************************************************************
.*        V9.03.01   01/03/2004  Pat Dirito                                   *
.*                   Added IBASTP17 - Allied Health Stationary Type           *
.******************************************************************************
.*        V9.02.01   09/11/2001  Bronko sosic                                 *
.*                   Added more fields in the form check for width            *
.******************************************************************************
.*        C2.00.03   27/06/2000  Charles Handaya                              *
.*                   Added new Stationery Types (15 & 16) for Cash Receipt    *
.*        C2.00.02   13/06/2000  Davin  SRF 2500                              *
.*                   Allow templating to maximum width of stationery          *
.*        C2.00.01   06/04/2000  Charles Handaya                              *
.*                   Added new Stationery Types (13 & 14) for Debtor          *
.*        C2.00.00   25/02/2000  Davin                                        *
.*                   Combined release 5 & 6 (all stationery types)            *
.******************************************************************************
.*        V5.07.02   09/07/1999  Nicole Harrington                            *
.*                   Added IBASTYP7 (Emergency Form)                          *
.*        V5.07.01   01/04/1999  Davin                                        *
.*                   Added IBASTYP6 (Health Fund Claim Form)                  *
.*        V5.07.B03  13/01/1999  Jim Stathopoulos                             *
.*                   Fixed Global Compile Errors                              *
.*        V5.07.B02  12/01/1999  Jim Stathopoulos                             *
.*                   Additional 507 Changes                                   *
.*        V5.07.B01  06/10/1999  Jim Stathopoulos                             *
.*                   507 Changes                                              *
.******************************************************************************
.*        V5.04.01  21/10/1996    Howellsy    EOC & ACC                       *
.*                  Added ACC Form. Stationery Type=5                         *
.******************************************************************************
.*           V5.01.01 18/03/90 E.Phan   No Srf                                *
.*                    Fixed up redisplays after Add & Change modes.           *
.*                    Added (S)ort mode, remove temp file before exit.        *
.*           V5.01.02 20/04/90 Graeme Williams                     SRF 104714 *
.*                    Fixed display of data item descriptions in change mode  *
.*           V5.01.03 30/05/90 Graeme Williams                                *
.*                    Added stationery types 31 and 32                        *
.*           V5.01.04 11/07/90 Peter Eddey                                    *
.*                    Added the copy template facility to the program.        *
.*           V5.01.05 01/10/90 Paul Marshall                                  *
.*                    Fixed defaults when changing Data item.                 *
.*           V5.01.06 10/03/91 Justin Coates                                  *
.*                    Re-compiled for extra order types                       *
.*           V5.01.07 20/05/91 Graeme Williams                                *
.*                    Fixed copy option to allow copying of stat. type 40.    *
.*           V5.01.08 05/09/91 Graeme Williams                     SRF 109964 *
.*                    Fixed insert option to accept types 1-4                 *
.*           V5.01.09 03/07/92 ROD                                 SRF 115157 *
.*                    Fixed I*U (delete not decrementing item nos)            *
.*           V5.01.10 10/03/93  Unknown                                       *
.*                    Some sort of problem was fixed (Dunno What)             *
.*           V5.01.11 10/03/93  ROD                                           *
.*                    Allow for new ibavr1af (Dudley)                         *
.*           V5.01.12 21/04/1993  Steve Armstrong                             *
.*                    Brought version into line                               *
.*           V5.01.13 16/03/1994  Matt Surridge                               *
.*                    Added program level locking and stationery keyin.       *
.*           V5.02.01  12/04/1995  Greg Horvat                                *
.*                     Removed the option for ibavr1af                        *
.*           V5.02.02 01/05/1995  Steve Armstrong                             *
.*                    Recompiled for IBASTPDS                                 *
.*                    22/05/1995  Steve Armstrong                             *
.*                    Recompiled for IBATMDDS                                 *
.*                                                                            *
.******************************************************************************
.
.$$$$$
.  Stationery Template Maintenance (IBATEM01)
.  ------------------------------------------
.
.  - Initialisation
.
.       - Display Header
.       - Open Files
.           IBATDET1
.           IBATMHA1
.           IBATMHA2
.           IBAVARD1
.           IBAVARD2
.
.  - Processing Options
.
.       - 0 = Exit
.       - 1 = Insert
.
.           - Display screen format
.                   - Clear all input variables
.           - Input stationery type and validate from IBATMHA1
.           - Accept initial stationery details
.                   - input stationery description
.                   - input maximum column width
.                   - input stationery length
.           - Select item to modify, Post, or Cancel
.           - If O.K. to Post, create indexed temp file ibatemXX where XX
.             is the unique user port number
.           - Process required fields on batch screen including all validation
.             for rows, columns, etc
.           - If O.K. to post,
.           - Write to IBATMHA1 and IBATDET1
.
.       - 2 = Change
.
.           - Display screen format
.           - Input stationery type and validate from IBATMHA1
.                    - Clear all input variables
.           - Display variables details
.           - Select item to modify, Post, or Cancel
.           - If O.K. to Post, create indexed temp file ibatemXX where XX
.             is the unique user port number
.           - Load the temp file ibatemXX with the existing data
.           - Process required fields on batch screen including all validation
.             for rows, columns, etc
.           - If O.K. to post,
.           - Update IBATMHA1 and IBATDET1
.
.       - 3 = Delete
.
.           - Display screen format
.           - Input stationery type and validate from IBATMHA1
.                   - Clear all display variables
.           - Display details
.           - O.K. to continue?
.           - If so delete from IBATMHA1 and IBATDET1
.
.  - END
.
.$$$$$
.
          INC       STD001FD
          INC       STDHLPDF
          INC       IBADSTYP/INC
          INC       IBATMDFD/INC
          INC       IBATMHFD/INC
          INC       IBAVARFD/INC
          INC       IBACONFD/INC
          INC       IBASEQFD/INC 
          INC       TFILEVAR/INC
          INC       WEBERRFD/INC
.
.**************************************************************************
.*                                TEMP FILE                               *
.**************************************************************************
IBATM1XX  IFILE     SQL, FIXED=60, KEY="U1-8,9-11,12-14"
IBATM2XX  IFILE     SQL, FIXED=60, KEY="U9-11,12-14,1-8"
.
DTMPUNIQ  DIM       8        8        1        Unique item count
DTMPROW   DIM       3        3        9        Row for printing
DTMPCOL   DIM       3        3        12       Column for printing
TMPTYPE   FORM      1        2        15       Data type  (1=Text  2=Data)
TMPVALU   DIM       40       40       17       Field no. or Text
TMPLNTH   FORM      3        3        57       Length to print
. End of Record                       60
.
. redefine form fields from key
. -----------------------------
TMPUNIQ   FORM      8
TMPROW    FORM      3
TMPCOL    FORM      3
+
.**************************************************************************
.*                                CONSTANTS                               *
.**************************************************************************
HFCFWDTH  INIT      "200"
.
OTHRWDTH  INIT      "132"
.
SP40      INIT      "                                        "
VARTYP1   INIT      "Text"
VARTYP2   INIT      "Data"
+
.**************************************************************************
.*                            GLOBAL VARIABLES                            *
.**************************************************************************
CHANGE    FORM      1
CMDLINE   DIM       60
COL       FORM      "23"
COUNT     FORM      3
COUNTER   FORM      8
CURRROW   FORM      3
CURRCOL   FORM      3
CURRTYPE  FORM      1
CURRVALU  DIM       40
CURRLNTH  FORM      3
CURRKY    DIM       5
.
DATATYPE  DIM       4
DIM3      DIM       3
DIM4      DIM       4
DIM6      DIM       6
DIM10     DIM       10
DIM15     DIM       15
.
FILENAME  DIM       8
FORM0P4   FORM      0.4
FORM10P4  FORM      10.4
FORM3     FORM      3
FORM4B    FORM      4
FORM8     FORM      8
.
KEYSTYPF  FORM      1
.
MAXWIDTH  FORM      3
MCURPAGE  FORM      3
MMAXPAGE  FORM      3
MMAXTRAN  FORM      4
MNUOPT    FORM      1
MODE      DIM       1
MREQPAGE  FORM      3
MSKIPASK  FORM      1
PROGMODE  DIM       1
.
QCOL      FORM      3
QVERT     FORM      2
.
ROW       FORM      2
.
SAVCCOL   FORM      3
SAVCOL    FORM      3
SAVCVERT  FORM      2
SAVKEY14  DIM       14
SAVLNTH   FORM      3
SAVROW    FORM      3
SAVTYPE   FORM      1
SAVVALU   DIM       40
SPSTATFL  FORM      1
STATTYPE  DIM       30
.
TEXTLENG  FORM      3
TEMPSCOD  DIM       6
TEMPDESC  DIM       30
TEMPWIDT  FORM      3                    
TEMPLENG  FORM      3
TEMPTYPE  FORM      3
TMPSDESC  DIM       30
THISPOS   FORM      3
.
PRGID     INIT      "IBATEM01"
PRGNAM    INIT      "Stationery Template Maintenance"
VERSION   INIT      "V12.01.00"
+
.**************************************************************************
.*                              MAINLINE                                  *
.*                            Controlling Logic                           *
.**************************************************************************
ML0000    CALL      INIT0000               * initialization and open files
          BRANCH    EXIT,ML9999
.
ML0100    CALL      OPTN0000               * select options
          BRANCH    EXIT,ML9999            * EXIT = 1 if 0 chosen in menu
          BRANCH    MNUOPT,ML1000,ML2000,ML3000,ML4000 
.
. ---- add template details code ----
.
ML1000    CALL      SCR0000                * display screen format
          MOVE      FOUR,ROW
          MOVE      ONE,SPSTATFL
          MOVE      ONE,CKEYTYP
          CALL      INP0000                * input stationery type
          BRANCH    EXIT,ML0100
          CALL      ACPT0000               * accept initial values
          BRANCH    EXIT,ML0100
          CALL      SEL0000                * select field to modify
.                                           * or ok to post
          BRANCH    EXIT,ML1000
          CALL      CREA0000               * kill and re-create the temp file
          CALL      MODB0000               * control block for batch screen
          BRANCH    EXIT,ML1000
          CALL      WRT0000                * write to files
          GOTO      ML1000
.
. ---- modify template details ----
.
ML2000    CALL      SCR0000                * display screen format
          MOVE      FOUR,ROW
          MOVE      ONE,SPSTATFL
          MOVE      ZERO,CKEYTYP
          CALL      INP0000                * input stationery details
          BRANCH    EXIT,ML0100
          CALL      DISP0000               * display details
          CALL      SEL0000                * select field to modify
.                                          * or ok to post
          BRANCH    EXIT,ML2000
          CALL      CREA0000               * kill and re-create the temp file
          CALL      LOAD0000               * load the temp file
          CALL      MODB0000               * control block for batch screen
          BRANCH    EXIT,ML2000
          CALL      UPD0000                * update records
          GOTO      ML2000
.
. ---- delete template details ----
.
ML3000    CALL      SCR0000                * display screen format
          MOVE      FOUR,ROW
          MOVE      ONE,SPSTATFL
          MOVE      ZERO,CKEYTYP
          CALL      INP0000                * input stationery details
          BRANCH    EXIT,ML0100
          CALL      DISP0000               * display detail
          CALL      CONT0000               * ok to delete ?
          BRANCH    EXIT,ML3000,ML0100
          CALL      DEL0000                * delete records
          GOTO      ML3000
.
. ---- copy template details  ----
.
ML4000    
          CALL      DCSC0000               * display copy screen
.
          MOVE      SIX,ROW
          MOVE      ZERO,CKEYTYP
          CALL      INP0000                * input stationery details
          BRANCH    EXIT,ML0100
.
          CALL      DCCF0000               * display the details
.
          CALL      ICTD0000               * input details of code to
          BRANCH    EXIT,ML0100              copy to.
.
          CALL      CONTQST                * ok to continue etc
          BRANCH    CEXIT,ML4500,ML4000,ML0100
.
ML4500    CALL      COPY0000
          GOTO      ML4000                 * Copy the template
.
ML9999    CALL      KILL0000               * Remove temp files
          CHAIN     PGM                    * chain back to program
+
.****************************************************************************
.*                                INIT0000                                  *
.*                             initialization                               *
.*  The initialization routine is used to display headings and open files.  *
.****************************************************************************
INIT0000  CALL      DISPHEAD                  * display heading
.
          MOVE      FALSE,EXIT
          OPEN      CONTROLF,"controlf"
.
          DISPLAY   *P50:24,*EL,"Opening ":
                    *P60:24,"ibatmdaf";
          OPEN      IBATDET1,"ibatmdaf"
.
          DISPLAY   *P60:24,"ibatmhaf";
          OPEN      IBATMHA1,"ibatmhaf"
.
          DISPLAY   *P60:24,"ibatmhaf";
          OPEN      IBATMHA2,"ibatmhaf"
.
          DISPLAY   *P60:24,"ibavaraf";
          OPEN      IBAVARD1,"ibavaraf"
          OPEN      IBAVARD2,"ibavaraf"
.
          CALL      TFILENAM
          MOVE      TFILNAME,FILENAME
.
          ADD       FORTY,NSORTNUM
.
INIT9999  RETURN
+
.****************************************************************************
.*                                OPTN0000                                  *
.*                        get user options or exit                          *
.*                                                                          *
.*    valid options     --->  (0) Exit                                      *
.*                            (1) Insert                                    *
.*                            (2) Change                                    *
.*                            (3) Delete                                    *
.****************************************************************************
.
. ---- display option screen ----
.
OPTN0000  
.
          DISPLAY   *P56:2,*EF
          HLINE     *G37,2,56,80
          DISPLAY   *P1:4,*V2LON,"0",*HOFF," = Exit":
                    *P1:5,*V2LON,"1",*HOFF," = Insert":
                    *P1:6,*V2LON,"2",*HOFF," = Change": 
                    *P1:7,*V2LON,"3",*HOFF," = Delete":
                    *P1:8,*V2LON,"4",*HOFF," = Copy":
                    *P1:10,"Select Option : "
.
OPTN1000  MOVE      SP1,PROGMODE
          KEYIN     *P17:10,*DV,UNDLN1:
                    *P17:10,*V2LON,MNUOPT:
                    *P17:10,*DV,MNUOPT
.
          COMPARE   ZERO,MNUOPT
          GOTO      OPTN9000 IF EQUAL             * exit
.
          BRANCH    MNUOPT,OPTN2100,OPTN2200,OPTN2300,OPTN2400
.
          BEEP
          GOTO      OPTN1000                      * invalid option, re-enter
.
OPTN2100
          DISPLAY   *P56:2,*EL,*V2LON,"- Insert"
          HLINE     *G37,2,65,80
          GOTO      OPTN8000
OPTN2200
          DISPLAY   *P56:2,*EL,*V2LON,"- Change"
          HLINE     *G37,2,65,80
          GOTO      OPTN8000
OPTN2300
          DISPLAY   *P56:2,*EL,*V2LON,"- Delete"
          HLINE     *G37,2,65,80
          GOTO      OPTN8000
OPTN2400
          DISPLAY   *P56:2,*EL,*V2LON,"- Copy"
          HLINE     *G37,2,63,80
          GOTO      OPTN8000
.
.------ valid option so set up program mode ------
.
OPTN8000  LOAD      PROGMODE,MNUOPT,ANSI,ANSC,ANSD,ANSM
          MOVE      FALSE,EXIT
          GOTO      OPTN9999
.
.------ exit option chosen ------
.
OPTN9000  MOVE      TRUE,EXIT                     * set EXIT = 1
.
OPTN9999  RETURN
+
.**************************************************************************
.*                                  CLR0000                               *
.*                            clear global variables                      *
.**************************************************************************
CLR0000   MOVE      SP30,IBTHDESC
          MOVE      ZERO,IBTHWIDT
          MOVE      ZERO,IBTHLENG
          MOVE      SP30,IBTHSTYP
          MOVE      SP30,IBTHACTV
          MOVE      ZERO,IBTHSTFM
          MOVE      SP30,STATTYPE
          PACK      IBTHCOMM,SP30,SP30,SP30
          MOVE      SP30,IBTHCUID
          MOVE      SP30,IBTHCDAT
          MOVE      SP30,IBTHCTIM
          MOVE      SP30,IBTHUUID
          MOVE      SP30,IBTHUDAT
          MOVE      SP30,IBTHUTIM
          PACK      IBTHSPAR,SP30,SP30
.
CLR9999   RETURN
+
.**************************************************************************
.*                               INP0000                                  *
.*                       input stationery code                            *
.**************************************************************************
INP0000   CALL      CLR0000                 * clear input variables
          MOVE      "23",CCOL
          MOVE      ROW,CVERT
          MOVE      SP6,IBTHSCOD
.
          CALL      KIBTHA00
          BRANCH    EXIT,INP9000,INP9000
.
INP1900 
          COMPARE   TEN3,ROW             * test what keyin you are on
          GOTO      INP1950 IF EQUAL
.
          IF        MNUOPT=4
          CALL      DCSC0000
          CALL      DCCF0000
          ENDIF
          GOTO      INP3000
.     
INP1950  
          CALL      DCCT0000
.
INP3000   MOVE      FALSE,EXIT
          GOTO      INP9500
.
.------ no identification code entered ------
.
INP9000   MOVE      TRUE,EXIT
.
.------ need to clear input variables if in insert mode ------
.------ as a ? option will put values in the input variables ------
.
INP9500   MATCH     ANSI,PROGMODE
          CALL      CLR0000 IF EQUAL
.
INP9999   RETURN
+
.**************************************************************************
.*                                  ICTD0000                              *
.*                      Input the stationery to copy to details           *
.**************************************************************************
.
ICTD0000 
          MOVE      ZERO,EXIT
          MOVE      ONE,KEYSTYPF         * set if type has been keyed
          MOVE      IBTHSCOD,TEMPSCOD
          MOVE      IBTHDESC,TEMPDESC
          MOVE      IBTHWIDT,TEMPWIDT
          MOVE      IBTHLENG,TEMPLENG
          MOVE      IBTHSTFM,TEMPTYPE
.
.
ICTD1000  MOVE      ANSI,PROGMODE
          MOVE      TEN3,ROW
          MOVE      ONE,CKEYTYP
          CALL      INP0000              * input the staionery code
          BRANCH    EXIT,ICTD4500
          MOVE      ANSM,PROGMODE
.
          BRANCH    SPSTATFL,ICTD4000    * branch if special stationery
.                                          types (1-4)
ICTD2000  
          MOVE      ZERO,KEYSTYPF        * type has now been keyed
          MOVE      TEN5,ROW               (used for refreshing screen) 
          CALL      STYP0000
          BRANCH    EXIT,ICTD9000
.
          COMPARE   "40",TEMPTYPE        * Was the original type N.S.M. ?
          GOTO      ICTD3000 IF LESS     * No. Must be an exact match.
.
          COMPARE   "40",IBTHSTFM
          GOTO      ICTD3000 IF NOT LESS
.
          BEEP
          DISPLAY   *P1:24,*EL,"You Cannot Copy To This Stationery Type. ";
          CALL      HITENTER
          GOTO      ICTD2000
.
ICTD3000  COMPARE   IBTHSTFM,TEMPTYPE    * test if copying to same   
          GOTO      ICTD5000 IF EQUAL      stationery type
          BEEP
          DISPLAY   *P1:24,*EL,"WARNING: Stationery Type Is Not The Same. ";                 
          CALL      HITENTER
          GOTO      ICTD5000
.
.----- handle special stationery type (user cannot keyin) -----
.
ICTD4000   
          MOVE      TEMPTYPE,IBTHSTFM
          MOVE      SP30,STATTYPE
.
.-----  get the stationery type description ----
.
          COMPARE   FORTY,TEMPTYPE
          GOTO      ICTD4200 IF NOT LESS
.
          MOVE      IBASTYP0,STATTYPE
          LOAD      STATTYPE,TEMPTYPE,IBASTYP1,IBASTYP2,IBASTYP3,IBASTYP4:
                                      IBASTYP5,IBASTYP6,IBASTYP7,IBASTYP8:
                                      IBASTYP9,IBASTP10,IBASTP11,IBASTP12:
                                      IBASTP13,IBASTP14,IBASTP15,IBASTP16:
                                      IBASTP17,IBASTP18
          GOTO      ITCD4400
.
ICTD4200  MOVE      TEMPTYPE,NSORTYPE
          SUB       FORTY,NSORTYPE
          CALL      NSMORDES
          MOVE      NSORDESC,STATTYPE
.
ITCD4400  DISPLAY   *P23:15,*V2LON,TEMPTYPE,*HOFF:
                    *P30:15,STATTYPE
          GOTO      ICTD5000
.
ICTD4500  MOVE      ONE,EXIT
          GOTO      ICTD9999
.
ICTD5000  
          MOVE      TEN6,ROW
          CALL      DESC0000             * keyin code description
          GOTO      ICTD9999
.
ICTD9000  MOVE      TRUE,EXIT
.
ICTD9999 RETURN
.
+
.**************************************************************************
.*                                  SCR0000                               *
.*                         display screen format                          *
.**************************************************************************
SCR0000   DISPLAY   *P1:4,*EF:
                    *P1:6,*V2LON,ONE:
                    *P1:7,TWO:
                    *P1:8,THREE:
                    *P1:9,FOUR:
                    *P5:4,*HOFF,"Stationery Code : ":
                    *P2:6,".  Stationery Type : ":
                    *P2:7,".  Description     : ":
                    *P2:8,".  Width           : ":
                    *P2:9,".  Length          : ";
.
SCR9999   RETURN
+
.**************************************************************************
.*                                 DCSC0000                               *
.*                         display copy screen format                     *
.**************************************************************************
DCSC0000  DISPLAY   *P1:3,*EF:
                    *P1:4,*V2LON,"Copy from :":
                    *P5:6,*HOFF,"Stationery Code : ":
                    *P2:8,"   Stationery Type : ":
                    *P2:9,"   Description     : ":
                    *P1:11,*V2LON,"To :",*HOFF:
                    *P5:13,*HOFF,"Stationery Code : ":
                    *P2:15,"   Stationery Type : ":
                    *P2:16,"   Description     : "
.
DCSC9999  RETURN
+
.*************************************************************************
.*                                DISP0000                               *
.*                   display all data variable details                   *
.*************************************************************************
DISP0000  DISPLAY   *P23:6,*V2LON,IBTHSTFM;
.
          MOVE      SP30,STATTYPE
.
          COMPARE   FORTY,IBTHSTFM
          GOTO      DISP0800 IF NOT LESS
.
          MOVE      IBASTYP0,STATTYPE
          LOAD      STATTYPE,IBTHSTFM,IBASTYP1,IBASTYP2,IBASTYP3,IBASTYP4:
                                      IBASTYP5,IBASTYP6,IBASTYP7,IBASTYP8:
                                      IBASTYP9,IBASTP10,IBASTP11,IBASTP12:
                                      IBASTP13,IBASTP14,IBASTP15,IBASTP16:
                                      IBASTP17,IBASTP18
          GOTO      DISP1000
.
DISP0800  MOVE      IBTHSTFM,NSORTYPE
          SUB       FORTY,NSORTYPE
          CALL      NSMORDES
          MOVE      NSORDESC,STATTYPE
.
DISP1000  DISPLAY   *P30:6,STATTYPE:
                    *P23:7,*V2LON,IBTHDESC;
.
          COMPARE   ZERO,IBTHWIDT
          GOTO      DISP9999 IF EQUAL
.
          DISPLAY   *P23:8,*V2LON,IBTHWIDT:
                    *P23:9,IBTHLENG;
.
DISP9999  RETURN
+
.*************************************************************************
.*                                DCCF0000                               *
.*                   display code record to copy from                    *
.*************************************************************************
DCCF0000
          MOVE      ZERO,SPSTATFL
          DISPLAY   *P23:6,*V2LON,IBTHSCOD:
                    *P23:8,IBTHSTFM;
.
          MOVE      SP30,STATTYPE
.
          COMPARE   FORTY,IBTHSTFM
          GOTO      DCCF0800 IF NOT LESS
.
          MOVE      ONE,SPSTATFL
.
          MOVE      IBASTYP0,STATTYPE
          LOAD      STATTYPE,IBTHSTFM,IBASTYP1,IBASTYP2,IBASTYP3,IBASTYP4:
                                      IBASTYP5,IBASTYP6,IBASTYP7,IBASTYP8:
                                      IBASTYP9,IBASTP10,IBASTP11,IBASTP12:
                                      IBASTP13,IBASTP14,IBASTP15,IBASTP16:
                                      IBASTP17,IBASTP18
          GOTO      DCCF1000
.
DCCF0800  MOVE      IBTHSTFM,NSORTYPE
          SUB       FORTY,NSORTYPE
          CALL      NSMORDES
          MOVE      NSORDESC,STATTYPE
.
DCCF1000  DISPLAY   *P30:8,STATTYPE:
                    *P23:9,*V2LON,IBTHDESC
.
.
DCCF9999  RETURN
+
+
.*************************************************************************
.*                                DCCT0000                               *
.* display code record to copy to. (used after a ? on 2nd code or type   *
.*************************************************************************
DCCT0000  DISPLAY   *P23:8,*V2LON,TEMPTYPE;
.
          MOVE      SP30,STATTYPE
.
          COMPARE   FORTY,TEMPTYPE
          GOTO      DCCT0800 IF NOT LESS
.
          MOVE      IBASTYP0,STATTYPE
          LOAD      STATTYPE,TEMPTYPE,IBASTYP1,IBASTYP2,IBASTYP3,IBASTYP4:
                                      IBASTYP5,IBASTYP6,IBASTYP7,IBASTYP8:
                                      IBASTYP9,IBASTP10,IBASTP11,IBASTP12:
                                      IBASTP13,IBASTP14,IBASTP15,IBASTP16:
                                      IBASTP17,IBASTP18
          GOTO      DCCT1000
.
DCCT0800  MOVE      TEMPTYPE,NSORTYPE
          SUB       FORTY,NSORTYPE
          CALL      NSMORDES
          MOVE      NSORDESC,STATTYPE
.
DCCT1000  DISPLAY   *P30:8,STATTYPE:
                    *P23:9,*V2LON,TEMPDESC
.
          DISPLAY   *P23:13,*V2LON,IBTHSCOD,*HOFF
.
          COMPARE   "40",TEMPTYPE
          GOTO      DCCT3000 IF NOT LESS
.
          DISPLAY   *P23:15,TEMPTYPE:
                    *P30:15,STATTYPE
          GOTO      DCCT9999
.
DCCT3000             
          BRANCH    KEYSTYPF,DCCT9999
          DISPLAY   *P23:15,*V2LON,IBTHSTFM,*HOFF:
                    *P30:15,TMPSDESC
.
DCCT9999  RETURN
.*************************************************************************
.*                                  ACPT0000                             *
.*   INPUT mode only :      accept initial values                        *
.*************************************************************************
ACPT0000
          MOVE      FALSE,EXIT
          MOVE      SIX,ROW
          CALL      STYP0000                   * input stationery type
          BRANCH    EXIT,ACPT9999
.
          MOVE      SEVEN,ROW
          CALL      DESC0000                   * input stationery description
.
          CALL      WIDT0000                   * input width for printing
.
          CALL      LENG0000                   * input length of stationery
.
ACPT9999  RETURN
+
.**************************************************************************
.*                                 STYP0000                               *
.*                         Input stationery type                          *
.**************************************************************************
STYP0000  MOVE      SP3,IBTHSTYP
          MOVE      SP30,STATTYPE
.
          DISPLAY   *P23:ROW,*EL,UNDLN3;
          KEYIN     *P23:ROW,*V2LON,*RV,*JR,IBTHSTYP;   * keyin stationery type
          DISPLAY   *P23:ROW,*V2LON,IBTHSTYP;
.
          PACK      DIM3,SP1,SP1,EXITCHAR
          MATCH     DIM3,IBTHSTYP
          GOTO      STYP9990 IF EQUAL
.
          MATCH     SP3,IBTHSTYP                   * test for spaces
          GOTO      STYP9000 IF EQUAL
.
          MATCH     "  ?",IBTHSTYP                 * test for ?
          GOTO      STYP1000 IF NOT EQUAL
.
.------ Question mark entered ------
.
STYP0200 
          SUB       FORTY,NSORTNUM
          CALL      GETSCR00
          CALL      IBASTPDS                       * display all types
          ADD       FORTY,NSORTNUM
.
.------ Keyin stationery type on question mark option screen ------
.
STYP0210  MOVE      SP3,IBTHSTYP
          MOVE      SP30,STATTYPE
          DISPLAY   *P1:24,*EL,"Stationery Type : ":
                    *P19:24,UNDLN3;
          KEYIN     *P19:24,*V2LON,*RV,*JR,IBTHSTYP;    * keyin stationery type
          DISPLAY   *P19:24,*V2LON,IBTHSTYP;
.
          MATCH     "  ?",IBTHSTYP                  * test for ?
          GOTO      STYP0200 IF EQUAL
.
          MATCH     SP3,IBTHSTYP                    * test for spaces
          GOTO      STYP0350 IF EQUAL
.
          MATCH     DIM3,IBTHSTYP                    * test for spaces
          GOTO      STYP0370 IF EQUAL
.
.------ stationery type has been entered on question mark option screen ------
.
STYP0300  TYPE      IBTHSTYP
          GOTO      STYP0400 IF EQUAL
.
.------ spaces entered as stationery type ------
.
STYP0350  DISPLAY   *P1:24,*EL,*B,"Field is Mandatory.  ";
          CALL      HITENTER
          GOTO      STYP0210
.
STYP0370  MOVE      TRUE,EXIT
          GOTO      STYP0990
.
.------ stationery type has been entered as a number ------
.
STYP0400  MOVE      IBTHSTYP,IBTHSTFM
.
          COMPARE   ONE,IBTHSTFM               * test if less than 1
          GOTO      STYP0350 IF LESS
.
          COMPARE   IBTHSTFM,NSORTNUM          * Check for largest stat. type
          GOTO      STYP0500 IF NOT LESS
.
.------ stationery type entered is not on file ------
.
          DISPLAY   *P1:24,*EL,*B,"Stationery Type Not On File. ";
          CALL      HITENTER
          GOTO      STYP0210
STYP0500
.
          COMPARE   "40",IBTHSTFM
          GOTO      STYP0700 IF NOT LESS
.
          BRANCH    SPSTATFL,STYP0700
.
          BEEP
          DISPLAY   *P1:24,*EL,"You Cannot Copy To This Stationery Type. ";
          CALL      HITENTER
          GOTO      STYP0210
.
.------ stationery type is valid ------
.
.
STYP0700  MOVE      FALSE,EXIT
.
          COMPARE   FORTY,IBTHSTFM
          GOTO      STYP0800 IF NOT LESS
.
          MOVE      IBASTYP0,STATTYPE
          LOAD      STATTYPE,IBTHSTFM,IBASTYP1,IBASTYP2,IBASTYP3,IBASTYP4:
                                      IBASTYP5,IBASTYP6,IBASTYP7,IBASTYP8:
                                      IBASTYP9,IBASTP10,IBASTP11,IBASTP12:
                                      IBASTP13,IBASTP14,IBASTP15,IBASTP16:
                                      IBASTP17,IBASTP18
          GOTO      STYP0900
.
STYP0800  MOVE      IBTHSTFM,NSORTYPE
          SUB       FORTY,NSORTYPE
          CALL      NSMORDES
          MOVE      NSORDESC,STATTYPE
.
STYP0900 
          CALL      PUTSCR00
          MOVE      STATTYPE,TMPSDESC
          COMPARE   FOUR,MNUOPT
          GOTO      STYP0950 IF EQUAL
.
          CALL      DISP0000                        * Re-Display variables
          GOTO      STYP9999
.
STYP0950  CALL      DCCT0000
          GOTO      STYP9999
.
STYP0990  CALL      PUTSCR00
          BRANCH    EXIT,STYP9999
          GOTO      STYP9000
.
.
.------ stationery type entered with no ? option ------
.
STYP1000  TYPE      IBTHSTYP                        * make sure it is a number
          GOTO      STYP1300 IF EQUAL
.
.------ stationery type is in valid ------
.
STYP1100  
          GOTO      STYP9900
.
.------ stationery type has been entered as a number ------
.
STYP1300  MOVE      IBTHSTYP,IBTHSTFM
.
          COMPARE   ONE,IBTHSTFM              * test if less than one
          GOTO      STYP1100 IF LESS
.
          COMPARE   IBTHSTFM,NSORTNUM          * Check for largest stat. type
          GOTO      STYP1500 IF NOT LESS
.
.------ stationery type entered is not on file ------
.
          DISPLAY   *P1:24,*EL,*B,"Stationery Type Not On File. ";
          CALL      HITENTER
          GOTO      STYP0000
.
.------ valid stationery type has been entered ------
.
STYP1500  
.
          COMPARE   FORTY,IBTHSTFM
          GOTO      STYP2000 IF NOT LESS
.
          MOVE      IBASTYP0,STATTYPE
          LOAD      STATTYPE,IBTHSTFM,IBASTYP1,IBASTYP2,IBASTYP3,IBASTYP4:
                                      IBASTYP5,IBASTYP6,IBASTYP7,IBASTYP8:
                                      IBASTYP9,IBASTP10,IBASTP11,IBASTP12:
                                      IBASTP13,IBASTP14,IBASTP15,IBASTP16:
                                      IBASTP17,IBASTP18
          GOTO      STYP3000
.
STYP2000  MOVE      IBTHSTFM,NSORTYPE
          SUB       FORTY,NSORTYPE
          CALL      NSMORDES
          MOVE      NSORDESC,STATTYPE
.
STYP3000  DISPLAY   *P30:ROW,STATTYPE;
          MOVE      FALSE,EXIT
          GOTO      STYP9999
.
.------ No stationery type entered ------
.
STYP9000  DISPLAY   *P1:24,*EL,*B,"Field is Mandatory.  ";
          CALL      HITENTER
          GOTO      STYP0000
.
STYP9900  DISPLAY   *P1:24,*EL,*B,"Invalid Stationery Type.  ";
          CALL      HITENTER 
          GOTO      STYP0000
.
STYP9990  MOVE      TRUE,EXIT
.
STYP9999  RETURN
+
+
.**************************************************************************
.*                                 DESC0000                               *
.*                    Input stationery decsription                        *
.**************************************************************************
DESC0000  MOVE      SP30,IBTHDESC
          DISPLAY   *P23:ROW,*EL,UNDLN30;
          KEYIN     *P23:ROW,*V2LON,*RV,IBTHDESC;
          DISPLAY   *P23:ROW,*V2LON,IBTHDESC;
.
          ENDSET    IBTHDESC
          APPEND    SP30,IBTHDESC
          RESET     IBTHDESC
.
DESC9999  RETURN
+
.**************************************************************************
.*                                  WIDT0000                              *
.*                  Input maximum column width for printing               *
.**************************************************************************
WIDT0000  MOVE      ZERO,IBTHWIDT
          DISPLAY   *P23:8,*EL,UNDLN3;
          KEYIN     *P23:8,*V2LON,*RV,IBTHWIDT;
          DISPLAY   *P23:8,*V2LON,IBTHWIDT;
.
          COMPARE   ONE,IBTHWIDT                 * test width entered
          GOTO      WIDT1000 IF NOT LESS
          BEEP  
          GOTO      WIDT0000                     * invalid width
.
.------ compare width entered to maximum width allowed ------
.
WIDT1000  LOAD      MAXWIDTH,IBTHSTFM,OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      HFCFWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH:
                                      OTHRWDTH,OTHRWDTH,OTHRWDTH,OTHRWDTH
          COMPARE   IBTHWIDT,MAXWIDTH
          GOTO      WIDT9000 IF LESS
.
          GOTO      WIDT9999
.
.------ width is greater than the maximum width allowed ------
.
WIDT9000  DISPLAY   *P1:24,*EL,*B,"Maximum Width allowed is ",MAXWIDTH:
                    " Characters.  ";
          CALL      HITENTER
          GOTO      WIDT0000
.
WIDT9999  RETURN
+
.**************************************************************************
.*                                  LENG0000                              *
.*                     Input paper length of stationery                   *
.**************************************************************************
LENG0000  MOVE      ZERO,IBTHLENG
          DISPLAY   *P23:9,*EL,UNDLN3;
          KEYIN     *P23:9,*V2LON,*RV,IBTHLENG;
          DISPLAY   *P23:9,*V2LON,IBTHLENG;
.
          COMPARE   ONE,IBTHLENG                   * test paper length
          GOTO      LENG9999 IF NOT LESS
          BEEP  
          GOTO      LENG0000                       * invalid length
.
LENG9999  RETURN
+
.**************************************************************************
.*                                   SEL0000                              *
.*                         select field to modify or post                 *
.**************************************************************************
SEL0000   MOVE      FALSE,EXIT
.
          CALL      MAINQST
          COMPARE   ZERO,CCITEM                * ok to post
          GOTO      SEL9999 IF EQUAL
.
          COMPARE   "-1",CCITEM                * cancel option
          GOTO      SEL9000 IF EQUAL
.
          BRANCH    CCITEM,SEL1000,SEL2000,SEL3000,SEL4000
          BEEP
          GOTO      SEL0000                    * invalid selection
.
SEL1000  
          MOVE      SIX,ROW
          CALL      STYP0000                   * input stationery type
          BRANCH    EXIT,SEL9000
          GOTO      SEL0000
.
SEL2000  
          MOVE      SEVEN,ROW
          CALL      DESC0000             * input stationery description
          GOTO      SEL0000
.
SEL3000   CALL      WIDT0000                   * input width for printing
          GOTO      SEL0000
.
SEL4000   CALL      LENG0000                   * input length of stationery
          GOTO      SEL0000
.
.------ Cancel option chosen ------
.
SEL9000   MOVE      TRUE,EXIT
.
SEL9999   RETURN
+
.**************************************************************************
.*                              CONT0000                                  *
.*                         check if OK to Delete                          *
.**************************************************************************
CONT0000  CALL      DELQST                    * ask delete question
          REP       "102132",ANS
          MOVE      ANS,EXIT
.
CONT9999  RETURN
+
.**************************************************************************
.*                              WRT0000                                   *
.*                 write a new record to the ibatmhaf file                *
.*                 and the ibatmdaf file                                  *
.**************************************************************************
WRT0000   MOVE      SP30,IBTHSPAR
          MOVE      IBTHSCOD,KEY6
          CALL      WRIBTH1                    * write to the header file
.
          MOVE      SP20,KEY14
          CALL      RSTMPR2                     * position on the temp file
.
.------ read through the temp file ------
.
WRT1000   CALL      RKTMPR2
          BRANCH    OVRCD,WRT9999
.
.------ set up the variables ------
.
          MOVE      ZERO,IBDTCOLR
          MOVE      TMPTYPE,IBDTINDC
          MOVE      TMPLNTH,IBDTPLEN
          MOVE      TMPVALU,IBDTTXFL
          MOVE      SP30,IBDTSPAR
.
          PACK      KEY12,IBTHSCOD,TMPROW,TMPCOL
          CALL      WRIBDET1                     * write to the details file
.
          GOTO      WRT1000
.
WRT9999   RETURN
+
.***************************************************************************
.*                               UPD0000                                   *
.*                      update record and insert key if part of            *
.*                      key has been modified for ibatmhaf                 *
.***************************************************************************
UPD0000   CALL      UPIBTH1                    * update the header file
.
.------ Delete all the old details from the file ------
.
UPD0500   PACK      KEY12,IBTHSCOD,SP6
          CALL      RSIBDET1
          CALL      RKIBDET1
          BRANCH    OVRCD,UPD0900
.
          MATCH     IBTHSCOD,IBDTSCOD            * match stationery types
          GOTO      UPD0900 IF NOT EQUAL
.
          PACK      KEY12,IBDTSCOD,DIBDTROW,DIBDTCOL
          CALL      DEIBDET1                     * delete from the details file
          GOTO      UPD0500
.
.         Now post the new data back into the file
.
UPD0900   MOVE      SP20,KEY14
          CALL      RSTMPR2                     * position on the temp file
.
.------ read through the temp file ------
.
UPD1000   CALL      RKTMPR2
          BRANCH    OVRCD,UPD9999
.
.------ set up the variables ------
.
          MOVE      ZERO,IBDTCOLR
          MOVE      TMPROW,IBDTROW
          MOVE      TMPCOL,IBDTCOL
          MOVE      TMPTYPE,IBDTINDC
          MOVE      TMPLNTH,IBDTPLEN
          MOVE      TMPVALU,IBDTTXFL
          MOVE      IBTHSCOD,IBDTSCOD
          MOVE      SP30,IBDTSPAR
.
          PACK      KEY12,IBTHSCOD,TMPROW,TMPCOL
.
.------ write a new record to the details file ------
.
          CALL      WRIBDET1
          GOTO      UPD1000
.
UPD9999   RETURN
+
.****************************************************************************
.*                              DEL0000                                     *
.*                         delete an existing record                        *
.****************************************************************************
DEL0000   MOVE      IBTHSCOD,KEY6
          CALL      DEIBTH1                     * delete from the header file
.
.------ position on the details file ------
.
DEL1000   PACK      KEY12,IBTHSCOD,SP6
          CALL      RSIBDET1
          CALL      RKIBDET1
          BRANCH    OVRCD,DEL9999
.
          MATCH     IBTHSCOD,IBDTSCOD            * match stationery types
          GOTO      DEL9999 IF NOT EQUAL
.
          PACK      KEY12,IBDTSCOD,DIBDTROW,DIBDTCOL
          CALL      DEIBDET1                     * delete from the details file
          GOTO      DEL1000
.
DEL9999   RETURN
+
+
.****************************************************************************
.*                              COPY0000                                    *
.*                         Copy   an existing record                        *
.****************************************************************************
.
COPY0000
          MOVE      TEMPWIDT,IBTHWIDT
          MOVE      TEMPLENG,IBTHLENG
.
.----  Other record variables are already set ----
.
          PACK      KEY6,IBTHSCOD
          CALL      WRIBTH1
.
.----  copy across the actual template ----
.
          PACK      KEY12,TEMPSCOD,SP6
.
COPY1000  
          CALL      RSIBDET1
          CALL      RKIBDET1
          BRANCH    OVRCD,COPY9999
.
          MATCH     IBDTSCOD,TEMPSCOD
          GOTO      COPY9999 IF NOT EQUAL
.
          MOVE      IBTHSCOD,IBDTSCOD
          PACK      KEY12,IBDTSCOD,IBDTROW,IBDTCOL
          CALL      WRIBDET1
.
          PACK      KEY12,TEMPSCOD,IBDTROW,IBDTCOL
.
          GOTO      COPY1000
.
COPY9999  RETURN
.
.**********************************************************************
.*                              CREA0000                              *
.*                   Kill and Re-Create the Indexed Temp File         *
.**********************************************************************
CREA0000  CALL      KILL0000                  * kill existing temp file
.
.------ Build new indexed temp file ------
.
          CLEAR     CMDLINE
          APPEND    "isbuild ",CMDLINE
          APPEND    FILENAME,CMDLINE
          APPEND    " 60 u1-8,9-11,12-14 u9-11,12-14,1-8",CMDLINE
          APPEND    SP30,CMDLINE
          RESET     CMDLINE
.
.------ open the files after building ------
.
          EXECUTE   CMDLINE,TASKID
          OPEN      IBATM1XX,FILENAME
          OPEN      IBATM2XX,FILENAME
.
.------ initialise page count ------
.
          MOVE      ONE,MREQPAGE
.
CREA9999  RETURN
+
.**********************************************************************
.*                              KILL0000                              *
.*                  Kill the Tempfile if it Already Exists            *
.**********************************************************************
KILL0000  CLEAR     CMDLINE
          CLOSE     IBATM1XX
          CLOSE     IBATM2XX
          APPEND    "iserase ",CMDLINE
          APPEND    FILENAME,CMDLINE
          RESET     CMDLINE
.
          EXECUTE   CMDLINE,TASKID
.
KILL9999  RETURN
+
.********************************************************************** 
.*                              LOAD0000                              *
.*          Load the indexed temp file with the previous data         *
.********************************************************************** 
LOAD0000  MOVE      ZERO,COUNTER
          PACK      KEY12,IBTHSCOD,SP6
          CALL      RSIBDET1                  * position on the details file
.
.------ read through the temp file ------
.
LOAD1000  CALL      RKIBDET1
          BRANCH    OVRCD,LOAD9999
.
          MATCH     IBTHSCOD,IBDTSCOD         * match stationery types
          GOTO      LOAD9999 IF NOT EQUAL
.
.------ set up the variables ------
.
          ADD       ONE,COUNTER
          MOVE      IBDTINDC,TMPTYPE
          MOVE      IBDTPLEN,TMPLNTH
          MOVE      IBDTTXFL,TMPVALU
.
          PACK      KEY14,COUNTER,IBDTROW,IBDTCOL
          CALL      WRTMPR1                   * write to the temp file
.
          GOTO      LOAD1000
.
LOAD9999  RETURN
+
.********************************************************************** 
.*                               MODB0000                             *
.*      Control block for Adding, Changing, Deleting, Re-displaying   *
.*      or Exiting template data                                      *
.********************************************************************** 
MODB0000  MOVE      ZERO,CHANGE
          CALL      MAXP0000                * Get MMAXPAGE & MMAXTRAN
          CALL      DISB0000                * Display the screen
          MOVE      ZERO,MSKIPASK           * Stop display at every screen
          COMPARE   ZERO,MMAXTRAN           * No Records as Yet ?
          GOTO      MODB1000 IF EQUAL       * Yes - Go Straight to Add Mode
.
MODB0100  MOVE      TRUE,EXIT               * Set exit flag
          MOVE      SP1,ANS
          MOVE      ZERO,FORM2
          KEYIN     *P1:24,*EL,"(",*V2LON,*DV,ANSA,*HOFF,")dd":
                    ", (",*V2LON,*DV,ANSC,*HOFF,")hange":
                    ", (",*V2LON,*DV,ANSD,*HOFF,")elete":
                    ", (",*V2LON,*DV,ANSR,*HOFF,")edisplay":
                    ", (",*V2LON,*DV,ANSS,*HOFF,")ort":
                    ", (",*V2LON,*DV,ANSE,*HOFF,")xit":
                    ", (",*V2LON,*DV,ANSP,*HOFF,")ost : ",*V2LON,ANS
          ENDSET    ANS
          APPEND    SP1,ANS
          RESET     ANS
          REP       UPPLOW,ANS
          REP       "A1C2D3R4S5E6P7 010203040506070",ANS * Cannot enter numbers
          MOVE      ANS,FORM2
          BRANCH    FORM2,MODB1000,MODB2000,MODB3000,MODB4000,MODB5000:
                          MODB6000,MODB7000
          BEEP
          GOTO      MODB0100
.
.         Add items
.
MODB1000  CALL      MADD0000
          GOTO      MODB0100
.
.         Change items
.
MODB2000  CALL      MCHG0000
          GOTO      MODB0100
.
.         Delete items
.
MODB3000  CALL      MDEL0000
          GOTO      MODB0100
.
.         Redisplay screen
.
MODB4000  MOVE      ZERO,MSKIPASK            * Stop display at every screen
          CALL      DISB0000
          GOTO      MODB0100
.
.         Sort entries
.
MODB5000  CALL      REIN0000                 * Sort entries to row/col
          GOTO      MODB4000                 * Redisplay entries
.
.         Exit without posting
.
MODB6000  MOVE      FALSE,EXIT
          COMPARE   ZERO,CHANGE
          GOTO      MODB9999 IF EQUAL        * No changes made
          KEYIN     *P1:24,*EL,"Exit without posting changes. Ok to proceed (":
                    *V2LON,*DV,ANSY,*HOFF,*DV,SLASH,*V2LON,*DV,ANSN,*HOFF:
                    ") ? ",*B,*V2LON,ANS
          REP       UPPLOW,ANS
          CMATCH    ANSY,ANS
          GOTO      MODB9999 IF EQUAL
          GOTO      MODB0100
.
.         Exit ...
.
MODB7000  MOVE      ZERO,EXIT                * Unset exit flag - update files
          RETURN
.
MODB9999  MOVE      TRUE,EXIT
          RETURN
+
.********************************************************************** 
.*                                MADD0000                            *
.*                    Add data to the indexed temp file               *
.********************************************************************** 
MADD0000  DISPLAY   *P1:24,*EL;
          MOVE      ANSI,MODE                * Insert mode
.
MADD0100  ADD       ONE,MMAXTRAN
          CALL      MAXP2000                 * Calculate new screen page
.
          COMPARE   MCURPAGE,MMAXPAGE        * Is curr scrn page the end ?
          GOTO      MADD1000 IF EQUAL        * Yes - calculate screen pos
          MOVE      MMAXPAGE,MREQPAGE        * else display last screen
          MOVE      ONE,MSKIPASK             * Stop display at last screen
          CALL      DISB0000                 * because MMAXPAGE=last screen page
.
.         Calculate screen position
.
MADD1000  MOVE      MCURPAGE,FORM4
          SUB       ONE,FORM4
          MULT      TEN6,FORM4
          MOVE      MMAXTRAN,FORM4B
          SUB       FORM4,FORM4B
          ADD       SIX,FORM4B
          MOVE      FORM4B,CVERT             * Position down the screen
.
          MOVE      MMAXTRAN,FORM3           * Transaction number
          DISPLAY   *P1:CVERT,*EL,*V2LON,FORM3,*HOFF,DOT;
.
. ----- Clear Temp File Variables -----
.
          MOVE      ZERO,TMPROW
          MOVE      ZERO,TMPCOL
          MOVE      ZERO,TMPTYPE
          PACK      TMPVALU,SP30,SP30
          MOVE      ZERO,TMPUNIQ
          MOVE      ZERO,TMPLNTH
.
          CALL      DATA0000                 * Input all batch data
          BRANCH    EXIT,MADD8500
.
.------------------------------------------------------------------------------
.         Write new record
.------------------------------------------------------------------------------
.
.------ set up temp file variables ------
.
          MOVE      MMAXTRAN,TMPUNIQ
.
          MOVE      CURRROW,TMPROW
          MOVE      CURRCOL,TMPCOL
          MOVE      CURRTYPE,TMPTYPE
          MOVE      CURRVALU,TMPVALU
          MOVE      CURRLNTH,TMPLNTH
.
          PACK      KEY14,TMPUNIQ,TMPROW,TMPCOL
          CALL      WRTMPR1                  * write to the temp file
.
          MOVE      ONE,CHANGE               * A change has been made
.
          GOTO      MADD0100                 * Add another record
.
.------ end of add mode so re-display screen ------
.
MADD8500  SUB       ONE,MMAXTRAN             * 1 less trx because we didn't add
          DISPLAY   *P1:CVERT,*EL            * Clear unused line number
.
MADD9999  RETURN
+
.********************************************************************** 
.*                           MCHG0000                                 *
.*              Change codes in the indexed temp file                 *
.********************************************************************** 
MCHG0000  DISPLAY   *P1:24,*EL;
          MOVE      ANSC,MODE                * Change mode
          KEYIN     *P1:24,*EL,"Change item : ",*V2LON,FORM4A;
          COMPARE   ZERO,FORM4A
          GOTO      MCHG9000 IF EQUAL
          COMPARE   MMAXTRAN,FORM4A
          GOTO      MCHG1000 IF EQUAL
          GOTO      MCHG1000 IF LESS
.
.------ item entered is not on file ------
.
MCHG0100  DISPLAY   *P1:24,*EL,*B,"Item Out Of Range. "; 
          CALL      HITENTER
          GOTO      MCHG0000
.
.         Calculate screen page transaction is on & transaction # down page
.
MCHG1000  MOVE      MMAXTRAN,FORM4           * Save MMAXTRAN
          MOVE      MMAXPAGE,FORM4B          * Save MMAXPAGE
          MOVE      FORM4A,MMAXTRAN          * Use trx num to calculate MMAXPAGE
          CALL      MAXP2000                 * Calculate MMAXPAGE
          MOVE      MMAXPAGE,MREQPAGE        * MMAXPAGE is the page req
          MOVE      FORM4,MMAXTRAN           * Restore MMAXTRAN
          MOVE      FORM4B,MMAXPAGE          * Restore MMAXPAGE
.
          COMPARE   MCURPAGE,MREQPAGE
          GOTO      MCHG1500 IF EQUAL
          MOVE      ONE,MSKIPASK             * Display till required screen
          CALL      DISB0000
.
.------ calculate the screen position ------
.
MCHG1500  MOVE      MCURPAGE,FORM4
          SUB       ONE,FORM4
          MULT      TEN6,FORM4
          MOVE      FORM4A,FORM4B
          SUB       FORM4,FORM4B
          ADD       SIX,FORM4B
          MOVE      FORM4B,CVERT             * Position down the screen
.
          MOVE      ZERO,FORM4               * Counter for no.of records read
          MOVE      SP20,KEY14
          CALL      RSTMPR1                  * position on the temp file
.
.------ read through the temp file ------
.
MCHG2000  CALL      RKTMPR1
          BRANCH    OVRCD,MCHG0100           * Record not found
          ADD       ONE,FORM4
          COMPARE   FORM4,FORM4A             * Same as transaction # ?
          GOTO      MCHG2900 IF EQUAL        * Yes - exit from read loop
          GOTO      MCHG2000                 * Otherwise keep on reading
.
.         Save current record's key for positioning read before update
.
MCHG2900  PACK      SAVKEY14,TMPUNIQ,TMPROW,TMPCOL
.
          MOVE      TMPROW,CURRROW
          MOVE      TMPCOL,CURRCOL
          MOVE      TMPTYPE,CURRTYPE
          MOVE      TMPVALU,CURRVALU
          MOVE      TMPLNTH,CURRLNTH
.
          MOVE      FORM4A,FORM8
.
          CALL      DATA0000                 * change batch data
          MOVE      TRUE,CHANGE              * change has been made
.
.------ update temp file ------
.
          MOVE      SAVKEY14,KEY14
          CALL      RDTMPR1                  * read the temp file
.
.-------- Post changes --------
.
          MOVE      CURRROW,TMPROW
          MOVE      CURRCOL,TMPCOL
          MOVE      FORM8,TMPUNIQ
          MOVE      CURRTYPE,TMPTYPE
          MOVE      CURRVALU,TMPVALU
          MOVE      CURRLNTH,TMPLNTH
.
          CALL      UPTMPR1                  * update the temp file
          GOTO      MCHG0000                 * Get next record to change
.
.         Exit from change mode
.
MCHG9000  RETURN
+
.********************************************************************** 
.*                              MDEL0000                              *
.*                 Delete codes from the indexed temp file            *
.********************************************************************** 
MDEL0000  KEYIN     *P1:24,*EL,"Delete item : ",*V2LON,FORM4A;
.
          COMPARE   ZERO,FORM4A
          GOTO      MDEL9000 IF EQUAL
.
          COMPARE   MMAXTRAN,FORM4A
          GOTO      MDEL1000 IF EQUAL
.
          GOTO      MDEL1000 IF LESS
.
.------ invalid item selected ------
.
          DISPLAY   *P1:24,*EL,*B,"Item Out Of Range. ";
          CALL      HITENTER
          GOTO      MDEL0000
.
.         Calculate screen page transaction is on & transaction # down page
.
MDEL1000  MOVE      MMAXTRAN,FORM4           * Save MMAXTRAN
          MOVE      MMAXPAGE,FORM4B          * Save MMAXPAGE
          MOVE      FORM4A,MMAXTRAN          * Use trx num to calculate MMAXPAGE
          CALL      MAXP2000                 * Calculate MMAXPAGE
          MOVE      MMAXPAGE,MREQPAGE        * MMAXPAGE is the page req
          MOVE      FORM4,MMAXTRAN           * Restore MMAXTRAN
          MOVE      FORM4B,MMAXPAGE          * Restore MMAXPAGE
.
          COMPARE   MCURPAGE,MREQPAGE
          GOTO      MDEL1500 IF EQUAL
          MOVE      ONE,MSKIPASK             * Display till required screen
          CALL      DISB0000
.
.------ calculate screen position ------
.
MDEL1500  MOVE      MCURPAGE,FORM4
          SUB       ONE,FORM4
          MULT      TEN6,FORM4
          MOVE      FORM4A,FORM4B
          SUB       FORM4,FORM4B
          ADD       SIX,FORM4B
          MOVE      FORM4B,CVERT             * Position down the screen
.
          MOVE      ZERO,FORM4               * Counter for no.of records read
          MOVE      SP20,KEY14
          CALL      RSTMPR1                  * position on the temp file
.
.------ read through the temp file ------
.
MDEL2000  CALL      RKTMPR1
          BRANCH    OVRCD,MDEL9100
.
          ADD       ONE,FORM4
          COMPARE   FORM4,FORM4A             * Same as transaction # ?
          GOTO      MDEL3000 IF EQUAL        * Yes - exit from read loop
          GOTO      MDEL2000                 * Otherwise keep on reading
.
.         Found record
.
MDEL3000  DISPLAY   *P6:CVERT,*V2LON,*BLINKON,TMPROW:
                    *P10:CVERT,TMPCOL;
.
.------ see if user wants to delete the item ------
.
MDEL3100  KEYIN     *P1:24,*EL,"Are you sure you want to delete this item (":
                    *V2LON,*DV,ANSY,*HOFF,*DV,SLASH,*V2LON,*DV,ANSN,*HOFF:
                    ") ? ",*V2LON,ANS
          REP       UPPLOW,ANS
          CMATCH    ANSY,ANS
          GOTO      MDEL4000 IF EQUAL
          CMATCH    ANSN,ANS
          GOTO      MDEL3200 IF EQUAL
          BEEP
          GOTO      MDEL3100                  * inavalid option
.
.------ not O.K. to delete the item ------
.
MDEL3200  DISPLAY   *P6:CVERT,TMPROW:
                    *P10:CVERT,TMPCOL;
.
          GOTO      MDEL0000
.
.         Delete record
.
MDEL4000  PACK      KEY14,TMPUNIQ,TMPROW,TMPCOL
          CALL      DETMPR1                  * delete from temp file
          CALL      ATMP0000                 * adjust temp file after delete
          CALL      MAXP0000                 * Recalculate MMAXPAGE & MMAXTRAN
          MOVE      ONE,MSKIPASK             * Display till required screen
          CALL      DISB0000
          GOTO      MDEL0000
.
MDEL9000  RETURN
.
.------ item selected is out of range ------
.
MDEL9100  KEYIN     *P1:24,*EL,*B,*V2LON,"*** SERIOUS ERROR *** ",*HOFF:
                    "Field required is past end of range ... ",*EOFF,ANS;
          GOTO      MDEL9000
+
.***************************************************************************
.*  ATMP0000  :  Adjust temp file after delete ie. sub one from every item *
.*               after deleted item so item no.'s are consecutive          *
.***************************************************************************
ATMP0000  CALL      RSTMPR1
ATMP1000  CALL      RKTMPR1
          BRANCH    OVRCD,ATMP9999
.
          SUB       ONE,TMPUNIQ
.
          CALL      UPTMPR1
          GOTO      ATMP1000
.
ATMP9999  RETURN
+
.********************************************************************** 
.*                                REIN0000                            *
.*        Routine to re-index the temp file after finishing in        *
.*        ADD mode or making a change in CHANGE mode                  *
.********************************************************************** 
REIN0000  MOVE      ZERO,COUNTER
          MOVE      SP20,KEY14
          CALL      RSTMPR2                  * position on the temp file
.
.------ read through the temp file ------
.
REIN1000  CALL      RKTMPR2
          BRANCH    OVRCD,REIN9999
.
          ADD       ONE,COUNTER
          MOVE      COUNTER,TMPUNIQ
          CALL      UPTMPR2                  * update the temp file
          GOTO      REIN1000
.
REIN9999  RETURN
+
.********************************************************************** 
.*                                DISB0000                            *
.*                    Redisplay batch keyin screen                    *   
.*                                                                    *
.*   Requires : MSKIPASK - 0=Accept/More asked  1=disp till MREQPAGE  *
.*   Returns  : MCURPAGE - Current displayed screen page              *
.********************************************************************** 
DISB0000  DISPLAY   *P1:4,*EF:
                    *P5:4,"Stationery Code : ",*V2LON,IBTHSCOD:
                    *P40:4,*HOFF,IBTHDESC;
.
          DISPLAY   *P1:6,*ULON,*V2LON,"Item":
                    *P6:6,"Row":
                    *P10:6,"Col":
                    *P14:6,"Type":
                    *P19:6,"Field No./Text                          ":
                    *P60:6,"Length";
.
          MOVE      ONE,MCURPAGE                * Current screen page is 1st
          MOVE      SEVEN,CVERT
          MOVE      ONE,FORM3
.
.------ position on the temp file ------
.
          MOVE      SP20,KEY14
          CALL      RSTMPR1
.
.------ read through the temp file ------
.
DISB1000  CALL      RKTMPR1
          BRANCH    OVRCD,DISB9999
.
          COMPARE   ZERO,MSKIPASK               * displaying all entries
          GOTO      DISB2000 IF EQUAL
.
          COMPARE   MREQPAGE,MCURPAGE           * skip if not required page
          GOTO      DISB2100 IF NOT EQUAL
.
.------ display details ------
.
DISB2000  DISPLAY   *P1:CVERT,*V2LON,FORM3,*HOFF,DOT:
                    *P6:CVERT,*HOFF,TMPROW:
                    *P10:CVERT,TMPCOL;
.
          LOAD      DATATYPE,TMPTYPE,VARTYP1,VARTYP2
.
          DISPLAY   *P14:CVERT,DATATYPE:
                    *P19:CVERT,TMPVALU:
                    *P62:CVERT,TMPLNTH;
.
.------ test to see if paging is required ------
.
DISB2100  ADD       ONE,FORM3
          ADD       ONE,CVERT
          COMPARE   CVERT,TWENTY2
          GOTO      DISB3000 IF LESS
          GOTO      DISB1000
.
.------ page full see if more desired ------
.
DISB3000  BRANCH    MSKIPASK,DISB3050          * skip if not asking question
          KEYIN     *P1:24,*EL,"(",*V2LON,*DV,ANSM,*HOFF,")ore, ":
                    "(",*V2LON,*DV,ANSA,*HOFF,")ccept this screen ? ":
                    *V2LON,ANS
          RESET     ANS
          GOTO      DISB9999 IF EOS
          REP       UPPLOW,ANS
          CMATCH    ANSA,ANS
          GOTO      DISB9999 IF EQUAL
          CMATCH    ANSM,ANS
          GOTO      DISB3100 IF EQUAL
          BEEP
          GOTO      DISB3000                   * invalid option
.
.         Skipped question - keep on displaying if not page required
.
DISB3050  COMPARE   MCURPAGE,MREQPAGE
          GOTO      DISB9999 IF EQUAL
.
.------ More option chosen ------
.
DISB3100  MOVE      SEVEN,CVERT
          ADD       ONE,MCURPAGE
          DISPLAY   *P1:CVERT,*EF;
.
          GOTO      DISB1000
.
DISB9999  RETURN
+
.**************************************************************************
.*                                  CURR0000                              *
.*         Routine to re-display the current record after a ? option      *
.**************************************************************************
CURR0000  MATCH     ANSC,MODE                   * test for change mode
          GOTO      CURR1000 IF NOT EQUAL
.
          MOVE      FORM8,FORM3
.
.------ display current record details ------
.
CURR1000  DISPLAY   *P1:CVERT,*V2LON,FORM3,*HOFF,DOT:
                    *P6:CVERT,CURRROW:
                    *P10:CVERT,CURRCOL;
.
          LOAD      DATATYPE,CURRTYPE,VARTYP1,VARTYP2
.
          DISPLAY   *P14:CVERT,DATATYPE:
                    *P19:CVERT,CURRVALU;
.
          MATCH     ANSI,MODE                   * test for insert mode
          GOTO      CURR9999 IF EQUAL
.
          DISPLAY   *P62:CVERT,CURRLNTH;
.
CURR9999  RETURN
+
.********************************************************************** 
.*                               MAXP0000                             *
.*              Routine to find MMAXPAGE & MMAXTRAN                   *
.********************************************************************** 
MAXP0000  MOVE      ZERO,MMAXTRAN
          MOVE      SP20,KEY14
          CALL      RSTMPR1                  * position on temp file
.
.------ read through temp file ------
.
MAXP1000  CALL      RKTMPR1
          BRANCH    OVRCD,MAXP2000
          ADD       ONE,MMAXTRAN
          GOTO      MAXP1000
.
.------ calculate MMAXPAGE ------
.
MAXP2000  MOVE      MMAXTRAN,FORM10P4        * Big number so no roundoff errors
          DIV       TEN6,FORM10P4            * 16 transactions per page
          MOVE      FORM10P4,DIM15           * Exact DIM copy so no roundup
          MOVE      DIM15,DIM10              * Only mantissa required
          UNPACK    DIM10,DIM6,DIM4          * DIM6 dummy variable
          REP       " 0",DIM4                * In case DIM4=SP4
          MOVE      DIM4,MMAXPAGE            * DIM4 to FORM4 - exact copy
          MOVE      FORM10P4,FORM0P4         * Remove mantissa
          MOVE      FORM0P4,FORM10P4         * Use only fractions
          MULT      "10000",FORM10P4         * Remove fractions
          COMPARE   ZERO,FORM10P4            * Right on page boundary ?
          RETURN    IF EQUAL                 * Yes - exit
          ADD       ONE,MMAXPAGE
          RETURN
+
.********************************************************************** 
.*                               DATA0000                             *
.*               Routine to input all the batch data                  *
.********************************************************************** 
DATA0000  CALL      ROW0000                   * input row for printing
          BRANCH    EXIT,DATA9999
.
DATA1000  CALL      COL0000                   * input column for printing
          BRANCH    EXIT,DATA0000
.
DATA2000  CALL      TYPE0000                  * input data type 
          BRANCH    EXIT,DATA1000
.
DATA3000  CALL      VALU0000                  * input data value
          BRANCH    EXIT,DATA2000
.
DATA4000  CALL      LNTH0000                  * input data length
          BRANCH    EXIT,DATA3000
.
          MOVE      FALSE,EXIT
.
DATA9999  RETURN
+
.********************************************************************** 
.*                                ROW0000                             *
.*               Routine to input the row for printing                *
.********************************************************************** 
ROW0000   MATCH     ANSC,MODE                   * test for change mode
          GOTO      ROW0100 IF NOT EQUAL
.
          MOVE      CURRROW,SAVROW              * save default row
          GOTO      ROW0200
.
.------ insert mode so initialise to zero ------
.
ROW0100   MOVE      ZERO,CURRROW
          MOVE      ZERO,SAVROW
          DISPLAY   *P6:CVERT,*EL;
.
.------ keyin the row ------
.
ROW0200   DISPLAY   *P6:CVERT,UNDLN3;
          KEYIN     *P6:CVERT,*V2LON,*RV,CURRROW;
          DISPLAY   *P6:CVERT,CURRROW;
.
          COMPARE   ONE,CURRROW                    * test if less than 1
          GOTO      ROW0300 IF NOT LESS
.
          MATCH     ANSI,MODE                      * test for insert mode
          GOTO      ROW9000 IF EQUAL
.
          MOVE      SAVROW,CURRROW                 * invalid option so
          BEEP                                       reset default
          GOTO      ROW0200
.
.------ test not greater than maximum page length ------
.
ROW0300   COMPARE   CURRROW,IBTHLENG
          GOTO      ROW8000 IF LESS
.
          MOVE      FALSE,EXIT
          GOTO      ROW9999
.
.------ row is greater than the page length ------
.
ROW8000   DISPLAY   *P1:24,*EL,*B,"Row Selected Is Greater The Page Length. ";
          CALL      HITENTER
          MOVE      SAVROW,CURRROW
.
          GOTO      ROW0200
.
.------ no row entered when in insert mode ------
.
ROW9000   MOVE      TRUE,EXIT
.
ROW9999   RETURN
+
.********************************************************************** 
.*                                COL0000                             *
.*               Routine to input the column for printing             *
.*                                                                    *
.*   REQUIRES : FORM8    The transaction number we are changing when  *
.*                       in Change Mode                               *
.********************************************************************** 
COL0000   MATCH     ANSC,MODE                      * test for change mode
          GOTO      COL0100 IF NOT EQUAL
.
          MOVE      CURRCOL,SAVCOL                 * set up default column
          GOTO      COL0200
.
.------ insert mode so initialise columns to zero ------
.
COL0100   MOVE      ZERO,CURRCOL
          MOVE      ZERO,SAVCOL
.
.------ keyin column ------
.
COL0200   DISPLAY   *P10:CVERT,UNDLN3;
          KEYIN     *P10:CVERT,*V2LON,*RV,CURRCOL;
          DISPLAY   *P10:CVERT,CURRCOL;
.
          COMPARE   ONE,CURRCOL                 * see if less than one
          GOTO      COL7000 IF LESS
.
          COMPARE   CURRCOL,IBTHWIDT            * test less than maximum width
          GOTO      COL8000 IF LESS
.
          MATCH     ANSC,MODE                   * test for change mode
          GOTO      COL1000 IF EQUAL
.
.------ position on temp file ------
.
          PACK      KEY14,CURRROW,CURRCOL,SP8
          CALL      RSTMPR2
          CALL      RKTMPR2
          BRANCH    OVRCD,COL3000
.
          COMPARE   TMPROW,CURRROW              * compare rows
          GOTO      COL3000 IF NOT EQUAL
.
          COMPARE   TMPCOL,CURRCOL              * compare columns
          GOTO      COL3000 IF NOT EQUAL
.
          GOTO      COL6000
.
.------ position on the temp file ------
.
COL1000   PACK      KEY14,CURRROW,CURRCOL,SP8
          CALL      RSTMPR2
.
.------ get required record ------
.
COL1100   CALL      RKTMPR2
          BRANCH    OVRCD,COL3000
.
.------ if we get the current record we are changing than read again ------
.
          COMPARE   FORM8,TMPUNIQ
          GOTO      COL1100 IF EQUAL
.
          COMPARE   CURRROW,TMPROW              * test rows
          GOTO      COL3000 IF NOT EQUAL
.
          COMPARE   CURRCOL,TMPCOL              * test columns
          GOTO      COL3000 IF NOT EQUAL
.
          GOTO      COL6000
.
.------ perform extra validation ------
.
COL3000   CALL      VALD0000                    * validate new row and column
.                                                 doesn't overlap with others
          BRANCH    EXIT,COL6500
.
          MOVE      FALSE,EXIT
          GOTO      COL9999
.
.------ same row and column entered ------
.
COL6000   DISPLAY   *P1:24,*EL,*B,"Row And Column Already On File. "; 
          CALL      HITENTER
          MOVE      SAVCOL,CURRCOL
.
          GOTO      COL0200
.
.------ column entered overlaps with previous data ------
.
COL6500   DISPLAY   *P1:24,*EL,*B,"Existing Data Overlaps With This Column. ";
          CALL      HITENTER
          MOVE      SAVCOL,CURRCOL
.
          GOTO      COL0200
.
COL7000   MATCH     ANSI,MODE               * test for insert mode
          GOTO      COL9000 IF EQUAL
.
.------ invalid column entered ------
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Column Entered. "; 
          CALL      HITENTER
          MOVE      SAVCOL,CURRCOL
.
          GOTO      COL0200
.
.------ column entered is greater than the page width ------
.
COL8000   DISPLAY   *P1:24,*EL,*B,"Column Selected Is Greater Than The Page":
                    " Width. "; 
          CALL      HITENTER
          MOVE      SAVCOL,CURRCOL
.
          GOTO      COL0200
.
.------ no column entered when in insert mode ------
.
COL9000   MOVE      TRUE,EXIT
.
COL9999   RETURN
+
.********************************************************************** 
.*                               VALD0000                             *
.*              Routine to validate the Row and Column for            *
.*              a given entry in Insert or Change mode                *
.*              i.e. Making sure they don't overlap                   *
.********************************************************************** 
VALD0000  MATCH     ANSC,MODE                   * test for change mode
          GOTO      VALD1000 IF EQUAL
.
.------ position on the temp file and get the previous record ------
.
          PACK      KEY14,CURRROW,CURRCOL,SP8
          CALL      RSTMPR2
          CALL      RPTMPR2
          BRANCH    OVRCD,VALD8000
.
          COMPARE   CURRROW,TMPROW              * don't validate if the rows
          GOTO      VALD8000 IF NOT EQUAL         are not equal
.
.------ test that current column is greater than or equal to ------
.------ the previous column added to the length of the previous item ------
.
          MOVE      TMPCOL,THISPOS
          ADD       TMPLNTH,THISPOS
.
          COMPARE   THISPOS,CURRCOL
          GOTO      VALD0100 IF LESS
.
          GOTO      VALD8000
.
.------ column is invalid ------
.
VALD0100  MOVE      TRUE,EXIT
          GOTO      VALD9999
.
.------ perform validation for change mode ------
.------ position on the temp file and get previous record ------
.
VALD1000  PACK      KEY14,CURRROW,CURRCOL,SP8
          CALL      RSTMPR2
          CALL      RPTMPR2
          BRANCH    OVRCD,VALD8000
.
          COMPARE   TMPUNIQ,FORM8             * if we get the same record again
          GOTO      VALD8000 IF EQUAL           then column must be valid
.
          COMPARE   CURRROW,TMPROW            * don't validate if the row is
          GOTO      VALD8000 IF NOT EQUAL       not the same
.
.------ test that current column is greater than or equal to ------
.------ the previous column added to the length of the previous item ------
.
          MOVE      TMPCOL,THISPOS
          ADD       TMPLNTH,THISPOS
.
          COMPARE   THISPOS,CURRCOL
          GOTO      VALD1100 IF LESS
.
          GOTO      VALD8000
.
.------ column is invalid ------
.
VALD1100  MOVE      TRUE,EXIT
          GOTO      VALD9999
.
.------ column is O.K. ------
.
VALD8000  MOVE      FALSE,EXIT
.
VALD9999  RETURN
+
.********************************************************************** 
.*                                TYPE0000                            *
.*                         Input the data type                        *
.********************************************************************** 
TYPE0000  MATCH     ANSC,MODE                * test for change mode
          GOTO      TYPE0100 IF NOT EQUAL
.
          MOVE      CURRTYPE,SAVTYPE         * save default type
          GOTO      TYPE0200
.
.------ insert mode so initialise to zero ------
.
TYPE0100  MOVE      ZERO,CURRTYPE
          MOVE      ZERO,SAVTYPE
.
.------ keyin data type ------
.
TYPE0200  DISPLAY   *P1:24,*EL,*V2LON,ONE,*HOFF," = Text Item, ",*V2LON:
                                      TWO,*HOFF," = Data Item";
          DISPLAY   *P14:CVERT,UNDLN1,SP3;
          KEYIN     *P14:CVERT,*V2LON,*RV,CURRTYPE;
.
          COMPARE   ONE,CURRTYPE                   * test if less than 1
          GOTO      TYPE8000 IF LESS
.
          BRANCH    CURRTYPE,TYPE1000,TYPE1000
.
          GOTO      TYPE8100                       * invalid data type
.
.------ set up and display the data type ------
.
TYPE1000  LOAD      DATATYPE,CURRTYPE,VARTYP1,VARTYP2
          DISPLAY   *P14:CVERT,DATATYPE:
                    *P1:24,*EL;
          MOVE      FALSE,EXIT
          GOTO      TYPE9999
.
TYPE8000  MATCH     ANSI,MODE                * test for insert mode
          GOTO      TYPE9000 IF EQUAL
.
.------ invalid data type entered ------
.
TYPE8100  DISPLAY   *P1:24,*EL,*B,"Invalid Data Type. ";
          CALL      HITENTER
          MOVE      SAVTYPE,CURRTYPE
.
          GOTO      TYPE0200
.
.------ no data type entered when in insert mode ------
.
TYPE9000  MOVE      TRUE,EXIT
          DISPLAY   *P14:CVERT,SP1:
                    *P1:24,*EL;
.
TYPE9999  RETURN
+
.********************************************************************** 
.*                               VALU0000                             *
.*          Input the field no. or text for the corresponding         *
.*          data type                                                 *
.********************************************************************** 
VALU0000  MATCH     ANSC,MODE                    * test for change mode
          GOTO      VALU0100 IF NOT EQUAL
.      
          MOVE      CURRVALU,SAVVALU             * save default values
.
          COMPARE   CURRTYPE,SAVTYPE             * test to see if new type
          GOTO      VALU0200 IF EQUAL              was entered
.
.------ initialise to spaces ------
.
VALU0100  PACK      CURRVALU,SP20,SP20
          MOVE      CURRVALU,SAVVALU
.
.------ keyin data value ------
.
VALU0200  DISPLAY   *P19:CVERT,UNDLN20,UNDLN20;
          KEYIN     *P19:CVERT,*RV,*V2LON,CURRVALU;
          DISPLAY   *P19:CVERT,CURRVALU;
.
          MATCH     SP40,CURRVALU                * test for spaces
          GOTO      VALU8000 IF EQUAL
.
          MATCH     QUEST,CURRVALU               * test for ?
          GOTO      VALU1000 IF NOT EQUAL
.
          COMPARE   ONE,CURRTYPE                 * can only have ? for
          GOTO      VALU6500 IF EQUAL              data types
.
.------ ? option on field values ------
.
VALU0300  CALL      QVAL0000                     
          COMPARE   ZERO,OVRCD
          GOTO      VALU0400 IF EQUAL
.
          CALL      MAXP0000
          MOVE      SAVVALU,CURRVALU
          MOVE      CVERT,SAVCVERT
          MOVE      CCOL,SAVCCOL
.
          MOVE      MCURPAGE,MREQPAGE        * Current page is the req page
          MOVE      ONE,MSKIPASK
          CALL      DISB0000                 * Redisplay the batch screen
.
          MOVE      SAVCVERT,CVERT
          MOVE      SAVCCOL,CCOL
.
          CALL      CURR0000                  * re-display current record 
.
          GOTO      VALU0200
.
.------ keyin field value after ? option ------
.
VALU0400  MOVE      SAVVALU,CURRVALU
          DISPLAY   *P1:24,*EL,"Field No. : ",UNDLN3;
          KEYIN     *P13:24,*V2LON,*RV,CURRVALU;
.
          MATCH     QUEST,CURRVALU            * test for ?
          GOTO      VALU0300 IF EQUAL
.
          MATCH     SP40,CURRVALU             * test for spaces
          GOTO      VALU0500 IF NOT EQUAL
.
          MOVE      CVERT,SAVCVERT
          MOVE      CCOL,SAVCCOL
          MOVE      ONE,MSKIPASK
.
          MOVE      MCURPAGE,MREQPAGE        * Current page is the req page
          CALL      DISB0000                  * re-display the batch screen
.
          MOVE      SAVCVERT,CVERT
          MOVE      SAVCCOL,CCOL
.
          CALL      CURR0000                  * re-display current record 
.
          GOTO      VALU8500
.
.------ we have a value after ? option ------
.------ first test to see if it is the same as the save value ------
.------ i.e. a new value has not been entered ------
.
VALU0500  DISPLAY   *P13:24,*V2LON,CURRVALU;
.
          MATCH     CURRVALU,SAVVALU
          GOTO      VALU0550 IF NOT EQUAL
.
          PACK      CURRKY,CURRVALU
          PACK      CURRVALU,CURRKY
          GOTO      VALU0600
.
VALU0550  TYPE      CURRVALU              * test new field is actually a number
          GOTO      VALU0600 IF EQUAL
.
.------ invalid field number entered ------
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Field Number Entered. ";
          CALL      HITENTER
          GOTO      VALU0400
.
.------ we have a new field number ------
.
VALU0600  MOVE      CURRVALU,IBVRFNUM
          PACK      KEY8,IBTHSTFM,IBVRFNUM
          CALL      RDIBVAR2                  * read the variable definition
          COMPARE   ZERO,OVRCD                  file
.
          GOTO      VALU0800 IF EQUAL
.
.------ field number not on file ------
.
          DISPLAY   *P1:24,*EL,*B,"Field Number Not On File. "; 
          CALL      HITENTER
          GOTO      VALU0400
.
.------ re-display the screen ------
.
VALU0800  MOVE      CVERT,SAVCVERT
          MOVE      CCOL,SAVCCOL
          MOVE      ONE,MSKIPASK
.
          MOVE      MCURPAGE,MREQPAGE
          CALL      DISB0000                  * re-display the batch screen
.
          MOVE      SAVCVERT,CVERT
          MOVE      SAVCCOL,CCOL
.
          CALL      CURR0000                  * re-display current record 
.
          GOTO      VALU6000
.
.------ current value has been entered without a ? option ------
.
VALU1000  COMPARE   ONE,CURRTYPE              * test for a text item
          GOTO      VALU6500 IF EQUAL
.
          MATCH     CURRVALU,SAVVALU
          GOTO      VALU1100 IF NOT EQUAL
.
          PACK      CURRKY,CURRVALU
          PACK      CURRVALU,CURRKY
          GOTO      VALU1200
.
.------ a new value has been entered ------
.------ first test to see if a valid number has been entered ------
.
VALU1100  TYPE      CURRVALU
          GOTO      VALU1200 IF EQUAL
.
.------ invalid field number has been entered ------
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Field Number Entered. "; 
          CALL      HITENTER
          MOVE      SAVVALU,CURRVALU
.
          GOTO      VALU0000
.
.------ see if field number entered exists on file ------
.
VALU1200  MOVE      CURRVALU,IBVRFNUM
          PACK      KEY8,IBTHSTFM,IBVRFNUM
          CALL      RDIBVAR2                    * read variable definition file
          COMPARE   ZERO,OVRCD
          GOTO      VALU6000 IF EQUAL
.
.------ field number not on file ------
.
          DISPLAY   *P1:24,*EL,*B,"Field Number Not On File. "; 
          CALL      HITENTER
          MOVE      SAVVALU,CURRVALU
.
          GOTO      VALU0000
.
.------ set up the display value for the current value ------
.
VALU6000  CLEAR     CURRVALU
          APPEND    IBVRFNUM,CURRVALU
          APPEND    " - ",CURRVALU
          APPEND    IBVRDESC,CURRVALU
          APPEND    SP40,CURRVALU
          RESET     CURRVALU
.
.------ calculate the length of the field if it is a text field ------
.------ and display details ------
.
VALU6500  CALL      CALC0000               * calculate the length of the field
.                                            if it's a text field
          MOVELPTR  CURRVALU,TEXTLENG
          ENDSET    CURRVALU
          APPEND    SP40,CURRVALU
          RESET     CURRVALU
          DISPLAY   *P19:CVERT,CURRVALU;
.
          MOVE      FALSE,EXIT
          GOTO      VALU9999
.
VALU8000  MATCH     ANSI,MODE              * test for insert mode
          GOTO      VALU9000 IF EQUAL
.
.------ invalid field value entered ------
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Entry For Data Value. "; 
          CALL      HITENTER
          MOVE      SAVVALU,CURRVALU
.
          GOTO      VALU0200
.
.------ invalid field value entered after ? option ------
.
VALU8500  MATCH     ANSI,MODE              * test for insert mode
          GOTO      VALU9000 IF EQUAL
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Entry For Data Value. ";
          CALL      HITENTER
          GOTO      VALU0400
.
.------ no data value entered in insert mode ------
.
VALU9000  MOVE      TRUE,EXIT
.
VALU9999  RETURN
+
.**************************************************************************
.*                                  QVAL0000                              *
.*                      ? option on field no.                             *
.**************************************************************************
QVAL0000  PACK      KEY33,IBTHSTFM,SP30
          CALL      RSIBVAR1                 * see if any variables exist
          CALL      RKIBVAR1
          BRANCH    OVRCD,QVAL2000
.
.------ Display Category Heading, and then loop over entries ------
.
          DISPLAY   *P1:4,*EF,*P30:4,*V2LON,*ULON,"VARIABLES AVAILABLE"
          MOVE      FIVE,QVERT
          MOVE      ONE,QCOL
.
          PACK      KEY33,IBTHSTFM,SP30
          CALL      RSIBVAR1                  * position on variables file
.
.------ Read through variable definition file ------
.
QVAL1000  CALL      RKIBVAR1
          BRANCH    OVRCD,QVAL4000
.
          COMPARE   IBTHSTFM,IBVRSTYP         * match stationery types
          GOTO      QVAL4000 IF NOT EQUAL
.
.------ Display variable codes and descriptions ------
.
          DISPLAY   *PQCOL:QVERT,*V2LON,IBVRFNUM,SP2,*HOFF,IBVRDESC;
          ADD       ONE,QVERT
.
          COMPARE   TWENTY3,QVERT             * see if paging is required
          GOTO      QVAL1000 IF LESS
.
.------ Set up second column display positions ------
.
          MOVE      FIVE,QVERT
          ADD       "40",QCOL
          COMPARE   "70",QCOL
          GOTO      QVAL1000 IF LESS
.
.------ Next screen or Exit ? ------
.
          KEYIN     *P1:24,*EL," (",*V2LON,"A",*HOFF,")ccept, (":
                    *V2LON,"N",*HOFF,")ext Screen : ",*V2LON,ANS;
.
          REP       UPPLOW,ANS
          CMATCH    ANSA,ANS
          GOTO      QVAL4000 IF EQUAL
.
.------ Reset to first column display positions ------
.
          MOVE      FIVE,QVERT
          MOVE      ONE,QCOL
          DISPLAY   *P1:5,*EF
.
          GOTO      QVAL1000
.
.------ No variables on file ------
.
QVAL2000  DISPLAY   *P1:4,*EF,*P30:4,*V2LON,*BLINKON,*B:
                    "No Variables on file";
.
          DISPLAY   *P1:24;
          CALL      HITENTER
.
          MOVE      TRUE,OVRCD
          GOTO      QVAL9999
.
.------ End of codes ------
.
QVAL4000  MOVE      ZERO,OVRCD
.
QVAL9999  RETURN
+
.**************************************************************************
.*                                  CALC0000                              *
.*           Calculate the length of a text field when in CHANGE mode     *
.**************************************************************************
CALC0000  COMPARE   ONE,CURRTYPE               * don't calculate if we have
          GOTO      CALC9999 IF NOT EQUAL        a data item
.
          MATCH     ANSC,MODE                  * no need to calculate if in
          GOTO      CALC9999 IF NOT EQUAL        insert mode
.
          ENDSET    CURRVALU
.
.------ bump over spaces ------
.
CALC1000  CMATCH    SP1,CURRVALU
          GOTO      CALC2000 IF NOT EQUAL
          BUMP      CURRVALU,-1
          GOTO      CALC1000
.
.------ set up length pointer to last alpha numeric character ------
.
CALC2000  LENSET    CURRVALU
          RESET     CURRVALU
.
CALC9999  RETURN
+
.**************************************************************************
.*                                 LNTH0000                               *
.*                      Input the field length                            *
.*   REQUIRES : FORM8   The transaction number we are changing when       *
.*                      in Change Mode                                    *
.**************************************************************************
LNTH0000  COMPARE   ONE,CURRTYPE                 * test if we have a text item
          GOTO      LNTH1000 IF NOT EQUAL
.
          MOVE      TEXTLENG,CURRLNTH
          DISPLAY   *P62:CVERT,CURRLNTH;
.
          GOTO      LNTH2000
.
.------ we have a data item so move variable length as the default ------
.
LNTH1000  MOVE      IBVRFLEN,CURRLNTH
          DISPLAY   *P62:CVERT,CURRLNTH;
.
          KEYIN     *P62:CVERT,*RV,*V2LON,CURRLNTH;
          DISPLAY   *P62:CVERT,CURRLNTH;
.
          COMPARE   "10",CURRLNTH
          GOTO      LNTH2000 IF EQUAL
.
          COMPARE   CURRLNTH,IBVRFLEN          * test field length is less than
          GOTO      LNTH2000 IF NOT LESS         or equal to the default
.
.------ invalid field length entered ------
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Length Entered. "; 
          CALL      HITENTER
.
          GOTO      LNTH0000
.
.------ continue validation ------
.
LNTH2000  COMPARE   ONE,CURRLNTH            * test if less than one
          GOTO      LNTH8000 IF LESS
.
.------ make sure column and length is not greater than maximum page width ----
.
          MOVE      CURRLNTH,THISPOS
          ADD       CURRCOL,THISPOS
          SUB       ONE,THISPOS             * get actual position (SRF 2500)
.
          COMPARE   THISPOS,IBTHWIDT
          GOTO      LNTH6000 IF LESS
.
          CALL      VALL0000                       * validate the length of the
.                                                    current field
          BRANCH    EXIT,LNTH7000
.
          MOVE      FALSE,EXIT
          GOTO      LNTH9999
.
.------ length will extend greater than the maximum page width ------
.
LNTH6000  DISPLAY   *P1:24,*EL,*B,"Length Entered Will Take You Over The Page":
                           " Width. ";
          CALL      HITENTER
.
          COMPARE   ONE,CURRTYPE                 * test if text item 
          GOTO      LNTH9000 IF EQUAL
.
          GOTO      LNTH0000
.
.------ length and column overlaps with previous data ------
.
LNTH7000  DISPLAY   *P1:24,*EL,*B,"Length Overlaps With Existing Data. ";
          CALL      HITENTER
.
          COMPARE   ONE,CURRTYPE                 * test if text item
          GOTO      LNTH9000 IF EQUAL
.
          GOTO      LNTH0000
.
LNTH8000  MATCH     ANSI,MODE                    * test for insert mode
          GOTO      LNTH9000 IF EQUAL 
.
.------ invalid length entered ------
.
          DISPLAY   *P1:24,*EL,*B,"Invalid Length Entered. ";
          CALL      HITENTER
.
          GOTO      LNTH0000
.
.------ no length entered when in insert mode or ------
.------ length is invalid for a text item ------
.
LNTH9000  MOVE      TRUE,EXIT
          DISPLAY   *P62:CVERT,SP4;
.
LNTH9999  RETURN
+
.**************************************************************************
.*                                 VALL0000                               *
.*               Validate the length of the field entered                 *
.**************************************************************************
VALL0000  MATCH     ANSC,MODE                   * test for change mode
          GOTO      VALL5000 IF EQUAL
.
.------ position on the next record in the temp file ------
.
          PACK      KEY14,CURRROW,CURRCOL,SP8
          CALL      RSTMPR2
          CALL      RKTMPR2
          BRANCH    OVRCD,VALL8000
.
          COMPARE   CURRROW,TMPROW              * don't validate if the rows
          GOTO      VALL8000 IF NOT EQUAL         are different
.
.------ make sure current column added to the length is less than or equal ----
.------ to the next column on the temp file ------
.
          MOVE      CURRLNTH,THISPOS
          ADD       CURRCOL,THISPOS
.
          COMPARE   THISPOS,TMPCOL
          GOTO      VALL8000 IF NOT LESS
.
          GOTO      VALL9000
.
.------ validation for change mode ------
.
VALL5000  PACK      KEY14,CURRROW,CURRCOL,SP8
          CALL      RSTMPR2                     * position on the temp file
.
.------ get the next record on the temp file ------
.
VALL6100  CALL      RKTMPR2
          BRANCH    OVRCD,VALL8000
.
.------ if we get the same record we are changing then we read the next ------
.------ one again ------
.
          COMPARE   FORM8,TMPUNIQ
          GOTO      VALL6100 IF EQUAL
.
          COMPARE   CURRROW,TMPROW           * don't validate if the rows are
          GOTO      VALL8000 IF NOT EQUAL      not the same
.
.------ make sure current column added to the length is less than or equal ----
.------ to the next column on the temp file ------
.
          MOVE      CURRCOL,THISPOS
          ADD       CURRLNTH,THISPOS
.
          COMPARE   THISPOS,TMPCOL
          GOTO      VALL8000 IF NOT LESS
.
          GOTO      VALL9000
.
.------ length is O.K. ------
.
VALL8000  MOVE      FALSE,EXIT
          GOTO      VALL9999
.
.------ length is invalid ------
.
VALL9000  MOVE      TRUE,EXIT
.
VALL9999  RETURN
+
.
.------ I/O Routines for temp file ------
.
RATMPR1   MOVE      ZERO,OVRCD
          RESET     KEY14
          READ      IBATM1XX,KEY14;ANS
          GOTO      OVERCOND IF OVER
          RETURN
.
RSTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY14
          READ      IBATM1XX,KEY14;;
          RETURN
.
RDTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY14
          READ      IBATM1XX,KEY14;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU:
                                   TMPLNTH
          GOTO      OVERCOND IF OVER
          MOVE      DTMPUNIQ,TMPUNIQ
          MOVE      DTMPROW,TMPROW
          MOVE      DTMPCOL,TMPCOL
          RETURN
.
RKTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY14
          READKS    IBATM1XX;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU:
                                   TMPLNTH
          GOTO      OVERCOND IF OVER
          MOVE      DTMPUNIQ,TMPUNIQ
          MOVE      DTMPROW,TMPROW
          MOVE      DTMPCOL,TMPCOL
          RETURN
.
RPTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY14
          READKP    IBATM1XX;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU:
                                   TMPLNTH
          GOTO      OVERCOND IF OVER
          MOVE      DTMPUNIQ,TMPUNIQ
          MOVE      DTMPROW,TMPROW
          MOVE      DTMPCOL,TMPCOL
          RETURN
.
WRTMPR1   MOVE      ZERO,OVRCD
          RESET     KEY14
          WRITE     IBATM1XX,KEY14;KEY14,TMPTYPE,TMPVALU,TMPLNTH
          RETURN
.
UPTMPR1   MOVE      TMPROW,DTMPROW
          MOVE      TMPCOL,DTMPCOL
          MOVE      TMPUNIQ,DTMPUNIQ
          UPDATE    IBATM1XX;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU,TMPLNTH
          RETURN
.
DETMPR1   RESET     KEY14
          DELETE    IBATM1XX,KEY14
          RETURN
.
RATMPR2   MOVE      ZERO,OVRCD
          RESET     KEY14
          READ      IBATM2XX,KEY14;ANS
          GOTO      OVERCOND IF OVER
          RETURN
.
RSTMPR2   MOVE      ZERO,OVRCD
          RESET     KEY14
          READ      IBATM2XX,KEY14;;
          RETURN
.
RDTMPR2   MOVE      ZERO,OVRCD
          RESET     KEY14
          READ      IBATM2XX,KEY14;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU:
                                   TMPLNTH
          GOTO      OVERCOND IF OVER
          MOVE      DTMPUNIQ,TMPUNIQ
          MOVE      DTMPROW,TMPROW
          MOVE      DTMPCOL,TMPCOL
          RETURN
.
RKTMPR2   MOVE      ZERO,OVRCD
          RESET     KEY14
          READKS    IBATM2XX;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU:
                                   TMPLNTH
          GOTO      OVERCOND IF OVER
          MOVE      DTMPUNIQ,TMPUNIQ
          MOVE      DTMPROW,TMPROW
          MOVE      DTMPCOL,TMPCOL
          RETURN
.
RPTMPR2   MOVE      ZERO,OVRCD
          RESET     KEY14
          READKP    IBATM2XX;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU:
                                   TMPLNTH
          GOTO      OVERCOND IF OVER
          MOVE      DTMPUNIQ,TMPUNIQ
          MOVE      DTMPROW,TMPROW
          MOVE      DTMPCOL,TMPCOL
          RETURN
.
UPTMPR2   MOVE      TMPROW,DTMPROW
          MOVE      TMPCOL,DTMPCOL
          MOVE      TMPUNIQ,DTMPUNIQ
          UPDATE    IBATM2XX;DTMPUNIQ,DTMPROW,DTMPCOL,TMPTYPE,TMPVALU,TMPLNTH
          RETURN
.
.         IO includes
.
          INC       STD001IO
          INC       STDHLPCD
          INC       IBASTPDS
          INC       IBATMDIO/INC
          INC       IBATMHKY
          INC       IBATMHIO/INC
          INC       IBAVARIO/INC
          INC       NSMORTYP
          INC       TFILENAM 
          INC       IBASEQIO/INC 
          INC       WEBERRIO/INC
